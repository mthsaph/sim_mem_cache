# -*- coding: utf-8 -*-
"""Arquitetura Trab Cache.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QfxW2VMrokR55IB1mGhGn-3MXcilTFU4
"""

import math # para fazer logaritmo sem ter que levantar tanto peso
import random # usada na função de geração de palavras
# o arquivo de informações deve conter informações da se seguinte maneira:
#256KB
#4
#32KB
#4
#Consultar a função size_to_bits para maior esclarecimento!

def dec_to_bin(num): # Recebe um inteiro. Converte decimal em um binário. Retorna um objeto tipo str().
  s = ""
  if num > 1:

    while num > 1:
      s = str(num%2) + s
      num = int(num/2)

    return (str(num) + s)
  else:
    return str(num)

def bin_to_dec(string): # Recebe uma string. Converte binário para decimal. Retorna um tipo int().
  exp = 0
  num = 0

  while string != "":
    num += int(string[-1]) * 2**exp
    string = string[:-1]
    exp += 1

  return int(num)

def word_gen(length): # função que gera palavras pseudoaleatorias para guardar na memória principal
  word = ""

  for i in range(length):
    word += str(random.randint(0, 1))

  return word

def gen_MP(MP, word = 32): # função de geração da memória principal, retorna uma matriz de inteiros, tamanhos sempre em bits
  MP["content"] = []
  block_size = int(MP["info"]["block_size"])
  mp_size = size_to_bits(MP["info"]["size"])
  num_block = mp_size // (block_size * word)
  add_size = MP["info"]["adds_size"]
  bin = ""
  a = ""

  for i in range(num_block):
    MP["content"].append([])
    for j in range(block_size):
      bin = dec_to_bin(block_size*i + j)
      a = (((add_size - len(bin)) * "0") + bin + (word_gen(word - add_size))) # usa uma função pseudoaleatoria para geração de palavras
      MP["content"][i].append(a) # keep this in mind

  return MP["content"]

def gen_cache(cache_size, block_size, word = 32): # função para geração da memória cache, retorna uma matriz de dicionários contendo endereço e vezes de endereço acessado, tamanhos sempre em bits
  cache = []
  block_size = int(block_size)
  cache_size = size_to_bits(cache_size)
  num_block = cache_size // (word * block_size)

  for i in range(num_block):
    cache.append([]) # gera o bloco da cache
    for j in range(block_size):
      cache[i].append({"Add": "", "Freq": 0}) # gera as linhas

  return cache

def size_to_bits(string): # pega uma string que indica o tamanha da memoria e retorna um inteiro que é o tamanho em bits
  dic = {"K": 2**10, "B": 8, "b": 1} # dicionário de conversão
  num = ""
  let = ""

  for i in string:
    if i in "0123456789":
      num += i
    else:
      let += i

  num = int(num)

  for i in let:
    num *= dic[i]

  return num

def read_info(string): #le as informações do arquivo
  f = open(string, "r")
  L = []
  for i in f:
    L.append(i.replace("\n", ""))

  f.close()
  return L

def read_adds(string): # le os endereços para acesso na MP
  f = open(string, "r")

  a = f.readline()

  f.close()

  L = []

  for i in a[:len(a) - 1].split(", "): # a[:len(a) - 1] para tirar o linebreak da string
    if check_add(MP, i):
      L.append(i)
    else:
      print("Erro: Endereço (" + i + ") inválido.\nEndereço removido!")

  return L

def hit_or_miss(CACHE, MP, add): # it works but lacks mathematical elegance, its not the work of a surgeon but a butcher!
  flag = 0
  x_loc = 0
  y_loc = 0
  xy_loc = 0
  menor = 0
  miss = 0
  hit = 0
  subs = 0

  for j in add:
    new_add = (MP["info"]["adds_size"] - len(j)) * "0" + j # transforma o endereço em um endereço de n bits, n sendo o número de bits nescessário para o endereçamento da MP
    x_loc = bin_to_dec(new_add[:len(new_add) - CACHE["info"]["d"]]) # descobrindo o bloco da MP
    xy_loc = x_loc % len(CACHE["content"]) # descobrindo o bloco da cache
    y_loc = bin_to_dec(new_add[len(new_add) - CACHE["info"]["d"]:]) # descobrindo a linha dentro do bloco da MP
    menor = CACHE["content"][xy_loc][0]["Freq"] # pega o tanto de x q o primeiro endereço daquele bloco da cache foi utilizado para comparação
    for i in range(len(CACHE["content"][xy_loc])): # começa a procurar no bloco
      if CACHE["content"][xy_loc][i]["Add"] == "":
          CACHE["content"][xy_loc][i] = {"Add": MP["content"][x_loc][y_loc], "Freq": 1}
          flag = 0
          print("MISS")
          print(CACHE["content"][xy_loc][i - 2: i])
          print("Linha acessada: ", CACHE["content"][xy_loc][i])
          print(CACHE["content"][xy_loc][i + 1: i + 3])
          miss += 1
          break;
      else:
        if CACHE["content"][xy_loc][i]["Add"][:MP["info"]["adds_size"]] == new_add:
          CACHE["content"][xy_loc][i]["Freq"] += 1
          flag = 0
          print("HIT")
          print(CACHE["content"][xy_loc][i - 2: i])
          print("Linha acessada: ", CACHE["content"][xy_loc][i])
          print(CACHE["content"][xy_loc][i + 1: i + 3])
          hit += 1
          break;
        else:
          if CACHE["content"][xy_loc][i]["Freq"] <= menor:
            menor = CACHE["content"][xy_loc][i]["Freq"]
            index = i
          flag = 1
    if flag:
      print("MISS")
      print("Linha sendo substituída: ", CACHE["content"][xy_loc][index])
      print(CACHE["content"][xy_loc][i - 2: i])
      print("Linha acessada: ", CACHE["content"][xy_loc][i])
      print(CACHE["content"][xy_loc][i + 1: i + 3])
      CACHE["content"][xy_loc][index] = {"Add": MP["content"][x_loc][y_loc], "Freq": 1}
      miss += 1
      subs += 1

  CACHE["info"]["misses"] = miss + CACHE["info"]["misses"]
  CACHE["info"]["hits"] = hit + CACHE["info"]["hits"]
  CACHE["info"]["subs"] = subs + CACHE["info"]["subs"]

  return CACHE

def check_add(MP, add):
  if len(add) > MP["info"]["adds_size"]:
    print("Endereço maior que o utilizado")
    return False
  else:
    for i in add:
      if i not in "01":
        print("Caracter (" + i + ") inválido")
        return False

    return True

def print_menu():
  option = ""
  print("Bem vindo ao simulador de memória cache! Em caso de dúvidas consulte o item 6 - Informações do programa")
  print("1 - Ler arquivo de informações")
  print("2 - Informar endereço de acesso")
  print("3 - Ler arquivo de sequência de endereços")
  print("4 - Imprimir MP")
  print("5 - Imprimir Cache")
  print("6 - Informações do programa")
  print("0 - Sair")
  option = input()
  return option

MP = {"content": [], "info":{"size": 0, "block_size": 0, "adds_size": 0, "word_size": 32}} # MP
CACHE = {"content": [], "info":{"size": 0, "block_size": 0, "word_size": 32, "s": 0, "d": 0, "tag": 0, "w": 0, "misses": 0, "hits": 0, "subs": 0}} # CACHE

flag = 0
hit_rate = 0
miss_rate = 0

while True:
  print("================================================================================")
  if flag == 1:
    print("Informações da MP: ")
    print(MP["info"])
    print("Informações do Cache: ")
    print(CACHE["info"])
  match print_menu():
    case "1":
      arq_info = input("Digite o nome do arquivo de informações: ")
      info = read_info(arq_info)
      MP["info"]["size"] = info[0]
      MP["info"]["block_size"] = info[1]
      MP["info"]["adds_size"] = int(math.log(size_to_bits(MP["info"]["size"]) / MP["info"]["word_size"], 2))
      MP["content"] = gen_MP(MP)
      CACHE["info"]["size"] = info[2]
      CACHE["info"]["block_size"] = info[3]
      CACHE["info"]["s"] = int(math.log(size_to_bits(MP["info"]["size"]) / 32, 2))
      CACHE["info"]["d"] = int(math.log(int(MP["info"]["block_size"]), 2))
      CACHE["info"]["tag"] = CACHE["info"]["s"] - CACHE["info"]["d"]
      CACHE["info"]["w"] = MP["info"]["word_size"] - MP["info"]["adds_size"]
      CACHE["content"] = gen_cache(CACHE["info"]["size"], CACHE["info"]["block_size"])
      print("Arquivo lido com sucesso!")
      flag = 1
    case "2":
      if flag == 0:
        print("Erro: Arquivo de informações não lido!")
      else:
        add = input("Digite o endereço de acesso (em binário): ")
        hit_or_miss(CACHE, MP, [add])
    case "3":
      if flag == 0:
        print("Erro: Arquivo de informações não lido!")
      else:
        arq_add = input("Digite o nome do arquivo de sequência de endereços (em binário): ")
        adds = read_adds(arq_add)
        hit_or_miss(CACHE, MP, adds)
    case "4":
      if flag == 0:
        print("Erro: Arquivo de informações não lido!")
      else:
        print(MP["content"])
    case "5":
      if flag == 0:
        print("Erro: Arquivo de informações não lido!")
      else:
        print(CACHE["content"])
    case "6":
      print("O arquivo de informações deve ser informado na forma de um string,")
      print("uma informação por linha, o acronimos suportados são K (2**10 bits), B (8 bits) e b (1 bit)")
      print("Exemplo:")
      print("256KB")
      print("4")
      print("32KB")
      print("4")
      print("O arquivo de sequência de endereços deve ser informado na forma de um string, com separação entre endereços sendo:, (UMA virgula e UM espaço)")
      print("O programa assume o arquito de endereços e informações como arquivos de texto, quando informando o nome inclua a terminação. EX: info.txt")
    case "0":
      if flag == 0:
        if CACHE["info"]["misses"] == 0 and CACHE["info"]["hits"] == 0 and CACHE["content"] != []:
          print("Cache vazio!")
        else:
          print("Erro: Arquivo de informações não lido!")
      else:
        if CACHE["info"]["misses"] == 0 and CACHE["info"]["hits"] == 0:
          print("Cache vazio!")
        else:
          print("Cache hit rate: ")
          hit_rate = CACHE["info"]["hits"] / (CACHE["info"]["hits"] + CACHE["info"]["misses"])
          print("%.2f%%" % (hit_rate * 100))
          print("Cache miss rate: ")
          miss_rate = CACHE["info"]["misses"] / (CACHE["info"]["hits"] + CACHE["info"]["misses"])
          print("%.2f%%" % (miss_rate * 100))
          print("Cache substituições: ")
          print(CACHE["info"]["subs"])
      print("Saindo...")
      break